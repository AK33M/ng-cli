// Generated by CoffeeScript 1.7.1
(function() {
  var Configstore, Helper, Promise, Runner, Sync, conf, sync, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Helper = require("./Helpers");

  Promise = require("bluebird");

  Sync = require("../bundled-commands/Sync");

  sync = new Sync();

  _ = require("lodash");

  Configstore = require("configstore");

  conf = new Configstore("angcli");

  Runner = (function(_super) {
    __extends(Runner, _super);

    function Runner() {
      return Runner.__super__.constructor.apply(this, arguments);
    }


    /**
      * @method addChildren
      * @private
      * @param index {String}
      * @param identifier {String}
      * @return dest {Object}
     */

    Runner.prototype.addChildren = function(index, identifier, dest) {
      var self;
      self = this;
      (index[identifier] || []).forEach(function(val) {
        dest.push({
          name: val.name,
          _init: val.path
        });
        self.addChildren(index, val.name, dest);
      });
    };

    Runner.prototype.sortModules = function(attached_with) {
      var defer, self;
      defer = Promise.defer();
      if (attached_with !== "new") {
        self = this;
        self.getConfig(function(err, config) {
          var app_root, saved_project_root;
          if (err) {
            self.trace(err);
          } else {
            app_root = config.project_root;
            saved_project_root = conf.get("project_root");
            if (!saved_project_root || saved_project_root !== app_root) {
              self.notify("info", "Project changed, re syncing hooks...");
              sync.init().then(function(response) {
                return sync.fetchModules(response);
              }).then(function(response) {
                return sync.registerModules(response);
              }).then(function(success) {
                self.notify("success", success);
                return self.serializeModules(attached_with).then(function(hooks) {
                  defer.resolve(hooks);
                });
              })["catch"](function(err) {
                defer.reject(err);
              });
            } else {
              return self.serializeModules(attached_with).then(function(hooks) {
                defer.resolve(hooks);
              });
            }
          }
        });
      } else {
        return this.serializeModules(attached_with);
      }
      return defer.promise;
    };


    /**
      * @method sortModules
      * @param attached_with {String} hook-for identifier
      * @return {promise} List of sorted hooks
      * @description sort and return hooks ready to be executed
     */

    Runner.prototype.serializeModules = function(attached_with) {
      var bundled, combinedModules, defer, dest, methods, modules, self;
      self = this;
      dest = [];
      defer = Promise.defer();
      methods = [];
      modules = require(this.local_modules);
      if (_.size(modules) > 0) {
        modules = JSON.parse(modules);
      }
      bundled = require(this.bundled_modules);
      if (_.size(bundled) > 0) {
        bundled = JSON.parse(bundled);
      }
      modules.standalone = modules.standalone || {};
      modules.depends = modules.depends || {};
      bundled.standalone = bundled.standalone || {};
      bundled.depends = bundled.depends || {};
      modules.standalone = _.zip(bundled.standalone, modules.standalone);
      modules.depends = _.zip(bundled.depends, modules.depends);
      modules.standalone = _.chain(modules.standalone).flatten(true).compact(true).sortBy(function(val) {
        return val.weight;
      }).value();
      modules.depends = _.chain(modules.depends).flatten(true).compact(true).sortBy(function(val) {
        return val.weight;
      }).value();
      combinedModules = modules.standalone.concat(modules.depends);
      combinedModules = _.filter(combinedModules, function(val) {
        return val.attached === attached_with;
      });
      self.addChildren(_.groupBy(combinedModules, "after"), void 0, dest);
      defer.resolve(dest);
      return defer.promise;
    };

    return Runner;

  })(Helper);

  module.exports = Runner;

}).call(this);
