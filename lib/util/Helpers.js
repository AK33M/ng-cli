// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var Elapsed, Helpers, LineUp, Promise, colors, findup, fs, lineup, nconf, path, _;

  findup = require("findup");

  fs = require("fs");

  path = require("path");

  Promise = require("bluebird");

  _ = require("lodash");

  nconf = require("nconf");

  nconf.use("memory");

  LineUp = require("lineup");

  lineup = new LineUp();

  Elapsed = require("elapsed");

  colors = require("colors");


  /**
   * Helper methods to perform different tasks
   * @class Helpers
   * @constructor
   */

  Helpers = (function() {
    function Helpers() {

      /**
         * @property config_file
         * @type {String} app config file
         * @final "ngconfig.json"
       */
      this.config_file = "ngconfig.json";

      /**
         * @property tasks_file
         * @type {String} app build tasks file
         * @final "tasks.js"
       */
      this.tasks_file = "tasks.js";

      /**
         * @property content_path
         * @type {String} path to content directory to save bundled and app specific hooks
       */
      this.content_path = path.join(__dirname, "../../content");

      /**
         * @property local_modules
         * @type {String} path to app specific hooks
       */
      this.local_modules = path.join(this.content_path, "modules.js");

      /**
         * @property bundled_modules
         * @type {String} path to bundled hooks
       */
      this.bundled_modules = path.join(this.content_path, "bundled.js");

      /**
         * @property project_path
         * @type {String} path to ngCli root
       */
      this.project_path = path.join(__dirname, "../../");
    }


    /**
       * @method notify
       * @param type {String} type of notificiation can be [error,warning,success,info]
       * @param msg {String} Message to display
     */

    Helpers.prototype.notify = function(type, msg) {
      return lineup.log[type](msg);
    };


    /**
       * @method actionMessage
       * @param action {String} string to highlight in green
       * @param message {String} message left
     */

    Helpers.prototype.actionMessage = function(action, message) {
      message = "" + (colors.green(action)) + " " + message;
      return console.log(message);
    };


    /**
       * @method getConfig
       * @return {callback} Returns callback with error or config object
     */

    Helpers.prototype.getConfig = function(cb) {
      var self;
      self = this;

      /**
         * @description Using finup to find config file down from cwd
       */
      findup(process.cwd(), self.config_file, function(err, dir) {
        var config_path;
        if (err) {
          cb({
            error: err,
            trace: {
              code: "NGE801",
              message: "Unable to locate " + self.config_file + " , make sure it is an ngCli project"
            }
          });
        } else {
          config_path = path.join(dir, self.config_file);
          fs.readFile(config_path, function(err, content) {
            var contentObj, e, returnObj;
            if (err) {
              cb({
                error: err,
                trace: {
                  code: "NGE802",
                  message: "Unable to locate " + self.config_file + " , make sure it is an ngCli project"
                }
              });
            } else {
              content = content.toString();
              try {
                contentObj = JSON.parse(content);
                returnObj = {
                  config: contentObj,
                  project_root: dir
                };
                cb(null, returnObj);
              } catch (_error) {
                e = _error;
                cb({
                  error: e,
                  trace: {
                    code: "NGE803",
                    message: "Unable to parse " + self.config_file + " , corrupt json file"
                  }
                });
              }
            }
          });
        }
      });
    };


    /**
       * @method getTasksFile
       * @return {callback} Returns callback with error or build tasks file path
     */

    Helpers.prototype.getTasksFile = function(cb) {
      var self;
      self = this;
      findup(process.cwd(), self.tasks_file, function(err, dir) {
        var file_path;
        if (err) {
          cb({
            error: err,
            trace: {
              code: "NGE811",
              message: "Unable to locate " + self.tasks_file + " , make sure it is an ngCli project or run npm install to install dependencies"
            }
          });
        } else {
          file_path = path.join(dir, self.tasks_file);
          return cb(null, file_path);
        }
      });
    };


    /**
      * @method getTasksFile
      * @private
      * @param model {Object} modules object to loop from
      * @param key {String} key to look for
      * @param attached_with {String} find hook is attached with which proccess
      * @return {object} Returns filtered model object
     */

    Helpers.prototype.queryDependent = function(model, key, attached_with) {
      return _.filter(model, function(val) {
        return val.after === key && val.attached === attached_with;
      });
    };


    /**
      * @method run
      * @param command {String} which command is getting executed
      * @param hooks_to_proccess {Object} list of hooks attached with executed command/process
      * @param config {Object} ngconfig object
      * @param args {Object} Command arguments
      * @description execute hooks configured with executed command/process
     */

    Helpers.prototype.run = function(command, hooks_to_proccess, config, args) {
      var hooks_methods, started_at, x;
      x = 0;
      hooks_methods = _.map(hooks_to_proccess, function(val) {
        return val._init;
      });
      started_at = new Date();
      Promise.reduce(hooks_methods, function(output, process) {
        if (typeof output === "string") {
          lineup.log.success(output);
        }
        if (typeof output === "function") {
          output = null;
        }
        console.log("\n" + colors.bold.underline("Executing " + hooks_to_proccess[x].name));
        x++;
        return process(output, config, args, nconf);
      }, 0).then(function(final_output) {
        var elapsedTime, time_spent;
        elapsedTime = new Elapsed(started_at, new Date());
        time_spent = elapsedTime.optimal || elapsedTime.milliSeconds + " milliseconds";
        lineup.log.success(final_output);
        console.log("Time spent " + time_spent);
        process.exit(0);
      })["catch"](function(err) {
        lineup.log.error(err);
        process.exit(1);
      });
    };


    /**
      * @method addChildren
      * @private
      * @param index {String}
      * @param identifier {String}
      * @return dest {Object}
     */

    Helpers.prototype.addChildren = function(index, identifier, dest) {
      var self;
      self = this;
      (index[identifier] || []).forEach(function(val) {
        dest.push({
          name: val.name,
          _init: require(val.path).init
        });
        self.addChildren(index, val.name, dest);
      });
    };


    /**
      * @method sortModules
      * @param attached_with {String} hook-for identifier
      * @return {promise} List of sorted hooks
      * @description sort and return hooks ready to be executed
     */

    Helpers.prototype.sortModules = function(attached_with) {
      var bundled, combinedModules, defer, dest, methods, modules, self;
      self = this;
      dest = [];
      defer = Promise.defer();
      methods = [];
      modules = require(this.local_modules);
      if (_.size(modules) > 0) {
        modules = JSON.parse(modules);
      }
      bundled = require(this.bundled_modules);
      if (_.size(bundled) > 0) {
        bundled = JSON.parse(bundled);
      }
      modules.standalone = modules.standalone || {};
      modules.depends = modules.depends || {};
      bundled.standalone = bundled.standalone || {};
      bundled.depends = bundled.depends || {};
      modules.standalone = _.zip(bundled.standalone, modules.standalone);
      modules.depends = _.zip(bundled.depends, modules.depends);
      modules.standalone = _.chain(modules.standalone).flatten(true).compact(true).sortBy(function(val) {
        return val.weight;
      }).value();
      modules.depends = _.chain(modules.depends).flatten(true).compact(true).sortBy(function(val) {
        return val.weight;
      }).value();
      combinedModules = modules.standalone.concat(modules.depends);
      combinedModules = _.filter(combinedModules, function(val) {
        return val.attached === attached_with;
      });
      self.addChildren(_.groupBy(combinedModules, "after"), void 0, dest);
      defer.resolve(dest);
      return defer.promise;
    };

    return Helpers;

  })();

  module.exports = Helpers;

}).call(this);
