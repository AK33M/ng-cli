// Generated by CoffeeScript 1.7.1
(function() {
  "use strict";
  var Gaze, Helpers, Promise, Tasks, helpers, minimatch, path, shelljs, _;

  Helpers = require("../util/Helpers");

  helpers = new Helpers();

  path = require("path");

  Promise = require("bluebird");

  _ = require("lodash");

  shelljs = require("shelljs");

  Gaze = require("gaze").Gaze;

  minimatch = require("minimatch");


  /**
     * Class to initiate watcher and run build tasks using ng-task-runner
     * @class Tasks
     * @constructor
   */

  Tasks = (function() {
    function Tasks() {
      this.watchers = {};
      this.identifiers = {};
      this.app_root = "";
      this.task_runner_path = "node_modules/ng-task-runner";
    }


    /**
       * @method parse
       * @description parse list of tasks written inside ng-task-runner/tasks.js file
       * @return {promise} Returns promise string with success or error
     */

    Tasks.prototype.parse = function() {
      var defer, self;
      self = this;
      defer = Promise.defer();
      helpers.getConfig(function(err, config) {
        var file, tasks;
        if (err) {
          defer.reject(err);
        } else {
          self.app_root = config.project_root;
          file = "" + config.project_root + "/" + self.task_runner_path + "/tasks.js";
          console.log(file);
          tasks = require(file)();
          _.each(tasks, function(values, keys) {
            self.identifiers[keys] = values["task-identifier"];
            if (values.watch) {
              self.watchers[keys] = {
                minimatch: values.watch.files,
                ignores: values.watch.ignore || {}
              };
            }
          });
          return defer.resolve("parsed tasks");
        }
      });
      return defer.promise;
    };


    /**
       * @method registerWatchers
       * @description register all required watchers to watch for file changes and run parsed tasks
       * @requires Gaze
     */

    Tasks.prototype.registerWatchers = function() {
      var files_to_watch, gaze, self;
      self = this;
      files_to_watch = [];
      _.each(self.watchers, function(values) {
        files_to_watch = files_to_watch.concat(values.minimatch);
      });
      gaze = new Gaze(files_to_watch, {
        cwd: this.app_root,
        matchEmptyDirs: true
      });
      return gaze.on("all", function(event, filepath) {
        return self.decideTasks(filepath);
      });
    };


    /**
       * @method decideTasks
       * @private
       * @param changedFile {String} path to file changed
       * @description Decide which tasks to run depending upon file changed
     */

    Tasks.prototype.decideTasks = function(changedFile) {
      var commands, self;
      commands = "";
      self = this;
      _.each(self.watchers, function(values, keys) {
        var keysFetched;
        keysFetched = false;
        return _.each(values.minimatch, function(pattern) {
          var ignore_files, pattern_ext;
          pattern = pattern.split("/");
          pattern_ext = pattern[pattern.length - 1];
          ignore_files = _.map(values.ignores, function(igf) {
            return path.join(self.app_root, igf);
          });
          if (minimatch(changedFile, pattern_ext, {
            matchBase: true
          }) && !_.contains(ignore_files, changedFile)) {
            if (!keysFetched) {
              commands += " " + self.identifiers[keys];
              keysFetched = true;
            }
          }
        });
      });
      if (_.size(commands) > 0) {
        shelljs.cd("" + self.app_root + "/" + self.task_runner_path);
        commands = "gulp build " + commands + " --path " + self.app_root;
        shelljs.exec(commands, function(status) {
          console.log(status);

          /* @todo Show successfull build message */
        });
      }
    };


    /**
       * @method runTasks
       * @description Run all tasks in one go for one time
     */

    Tasks.prototype.runTasks = function() {
      var commands, defer, self;
      self = this;
      defer = Promise.defer();
      commands = "";
      _.each(self.identifiers, function(v) {
        commands += " " + v;
      });
      if (_.size(commands) > 0) {
        shelljs.cd("" + self.app_root + "/" + self.task_runner_path);
        commands = "gulp build " + commands + " --path " + self.app_root;
        shelljs.exec(commands, function(status) {
          if (status === 0) {
            defer.resolve("build completed");
          } else {
            defer.reject("Error running build");
          }
        });
      } else {
        defer.resolve("No commands to run");
        return;
      }
      return defer.promise;
    };

    return Tasks;

  })();

  module.exports = Tasks;

}).call(this);
